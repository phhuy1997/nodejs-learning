1. NestJs Framework:
   Remove everything in this folder (because they are for the Express).

   $ npm install -g @nestjs/cli
   --> nest-cli will help us create a set of NestJs Project. (type "nest" for check).
   $ nest new .
   --> It will create a Nest Project in this folder
   --> Package.json, package-lock.json will automatically re-created (suitable for NestJs),
   --> Our server now will be run in /src/main.ts

2. Modules:
   On real project, each scope of an application will have many sections/features/...
   --> We can create many Modules according to that scope seperation.
   For Example: 1 parent Module: (AppModule: /app.module.ts)
                some childModules (UserModule: /user.module.ts) as child Module and imported into parent Module
   Import Parent Modules into main.ts
   
3. Controller:
   Create UserController: /src/users/user.controller.ts
   For using: Import UserController into /user.module.ts
   API in UserController:
      + Declare Router:  @Controller('users') 
      + Method @GET: GetAllUsers()
      + Method @POST: CreateUser()

4. Pipe 1: Validation:
   $ npm install class-validator
   a. Controller Validation: 
      @UsePipes in Controller (UserController) for auto validation and response to Client
      --> If validate fail, auto response error message to Client.
   b. Global Validation: (larger scope)
      In main.ts we can use: app.useGlobalPipes(new ValidationPipe())
      --> In UserController, we dont need to @UsePipes anymore

   In UserDTO, we can add  @IsNotEmpty, @Length, @IsPositive, @Max, @IsAlphanumeric, @IsAlphanumeric,... (https://github.com/typestack/class-validator)
   so that the input from Client always be validated automatically


4. Pipe 2: Transformer: 
   # Used to transform to expected input, remove unexpected input
   $ npm install class-transformer 
   a. Controller Transformer: 
      In UserController, we can use plainToClass(UserDTO, user, {excludeExtraneousValues: true}) to only get the only accepted field from input
      --> If validate fail, auto response error message to Client.
      In UserDTO, we can add  @Expose()
      so that the input from Client always be checked and filter only the accepted fields
   b. Global Transformer:
      We make UserDTO extends from BaseDTO (parent)
      In BaseDTO, we define a static method: exposedInput to return a result of plainToClass(...).
      --> In UserController, we don't need to plainToClass(...) anymore.

5. Dependency Injection (Basic):
   + Create UserRepository: 
      # It is a class for database representative
   + Create UserService: (with constructor(userRepository: UserRepository))
      # It contain the complex action be used in UserController (Ex: createUser)
   + In UserController:
      We can use Dependency Injection: 
         - To inject UserService into UserController
         - To inject UserRepository into UserService  --> UserService have enough ability to be init by constructor
      --> In UserController, we can use this.userService.createUser().

5. Dependency Injection (Module - useClass):
   + In UserController & UserRepository: Instead of declare userService, userRepository and inject seperately into constructor, we can passed them (ready to use directly) from Module outside.
   + In UserModule, declare providers we gather all Providers (UserService, UserRepository, UserSeviceA, UserServiceB,...),  into 1 Provider.
   --> easy to use and import. Very useful for mock tesing, download Service from package outside and inject into our Module

5. Dependency Injection (Module - useValue):
   + We create an Interface: StoreConfig
   + In UserModule, we add a value of storeConfig into Provider (useValue not useClass)
   + In UserController, we can inject storeConfig from Module into Constructor, and read it data directly in the @Get Method

5. Dependency Injection (Module - useFactory):
   + We create an Interface: StoreService.
   + In UserModule:
      - Create a function createService to return a StoreService 
      - We add a Provider (useFactory) of storeService into Module
   --> With UseFactory, the Provider can adapt parameter for the function to return different result to be use for injection. (Compared to "useValue", the Injection value can not be dynamic.)
   
   

   


How to run:
C1: nest start (default)
C2: npm run build (according to scripts)
