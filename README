1. Create package.json:
   npm init
   Then fill the information
   --> package.json will be automatically created

2. Express Framework:
   npm install express@4.18.2
   --> node_modules/... will be automatically created and includes express & related of express
   --> package-lock.json will be automatically created: It declares all detail package that was installed
   (more details than package.json)

3. View Render: (popular: EJS)
   npm install --save-exact ejs@3.1.8
   Then create folder /src/views/... to contain all file view .ejs
   Call the .ejs file from server.js

4. Set up ENV: (to dynamic port for each different enviroment that code will be run on)
   # instal dotenv package so that we can read the variables in the .env file through the process.env.<VARIALBLE>
   npm install --save-exact dotenv@16.0.3
   Create .env file
	 In server.js, we can envoke the VARIABLE from .env file

5. Nodemon DevTool:
	 # install Nodemon so that when there is any updated code (.js, .mjs), the server can be automatically reset without manually "npm run start" again
	 npm install --save-dev nodemon@2.0.20    (--save-dev means that package will only be used in devDependencies --> no need to be use this package when deploy to production)
   In package.json, change script to "nodemon ./src/server.js"

6. Static File:
   Create folder /public. --> Inside it, create folder /css, /js, /images
	 # Those folders will contain file that will be run on client.(ex:js will be used in <Scriptt> of the DOM in /views)
   Now, In server.js, We can use this code: app.use(express.static(path.join(__dirname, 'public')))
	 # Example When Client access url: http://localhost:3000/images/flezzexample.png, Client can read image in /images folder
	 In /views/sample.ejs, we add <img src="/images/flezzexample.png" alt=""> 
	 # --> Client can see image rendered in HTML because it was fetched from http://localhost:3000/images/flezzexample.png

7. Run Docker to use Database:
	 Download docker file: https://drive.google.com/file/d/1DfSjZTM8RYXbKCde5gRg_HYl3YJWNtGa/view
	 Save into our source: mysql.yml
	 Run: docker compose -f mysql.yml -p nodejs-sql up -d
	 Open Dbeaver, connection to DB: Port 3307, username: root, password: 132456.
	               then CREATE TABLE User (id, name, email, city)			
								 then INSERT INTO User (1, 'eric@gmail.com', 'hoidanit', 'hanoi')					 

8. Connection to DB:
	 npm install --save-exact mysql2@2.3.3
	 # We will use mysql2 with more new update feature
	 In Server.js, we can Create connection = mysql.createConnection({...}) 
	               then we can query to get data from DB


9. MVC Structure:
	 # Routes: Define Routes (/endpoint) and link to Controller to coordinate tasks (respective to each route)
   # Controller: to Coordinate the tasks on each request endpoint to respective Model, get result from Model and response to Client
	 # Model: to handle Logic, calculation, query database and pass request data to View for rendering (if SSR), return result to Controller
	 # View (if SSR): to render data gotten from Model request it to do.
	 a. Folder /config:
	 		In Server.js, Move section 'config template (view) engine' to /config/viewEngine.js
										Move section 'config static file' to /config/viewEngine.js also
										Move section 'Create connection to DB'   to  /config/database.js

	 b. Folder /routes:
	 		In Server.js, Move section declare router  to  /routes/web.js
	 c. Folder /controller:
      Handle controller, res.response, ... to /controller/homeController.js

10. Connection Pool:
	 # Help avoid open connection on every query. With this method, we can reuse the previous connection to query the data
	 # This will also help us in auto close the previous connection when we open a new connection to fetch the latest data
	 In database.js (file config database connection), we change "createConnection" to "createPool" 
	 																									then add some additional attributes: waitForConnections, connectionLimit, queueLimit


11. POST, GET, Request.Body, Request.Params
	GET:
	In /routes/web.js, we change "/abc" to "/:abc"
	In Controller 'GetABC" we can get that param by using "req.params.abc"

	POST:
	In /routes/web.js, we create an endpoint: POST '/create-user'
	In Controller, create 'postCreateUser", we can get request body from client by using "req.body"

12. API -  Restful API
	Build API Routes Same as web routes

13. Middleware:
	# Middleware is like a firewall, used to block, redirect, authenticate, ... every request from client
	



3. Install apollo-server-express, graphql, nodemon, mongoose, 
	+ npm i express apollo-server-express graphql nodemon 
	+ install Extension: GraphQl (by Orsen Kucher)

4. Start a Graphql through ApolloServer:
   + Create schema.js: define <typeDefs> includes: type Book & type Query
   + Create resolver.js: <resolver>
   + In server.js: 
      - Create a server through ApolloServer({typeDefs & resolver})
      - Run that server on PORT 3000/graphql

5. Query - by Id:
   + Move data the mockData.js for clearly manage.
   + In schema.js, type Query: add query key&value for BookById.
   + In resolver.js, add bookById for the expected returning data for that query (BookById).

5. Query - by master-detail relationship:
   + In mockData.js, add authorId for mocked-booksData
   + In schema.js, add field {author: Author} for Book Schema
   + In resolver.js, add Book resolver to map the "author" in schema   vs    "authorId" in mocked-booksData

6. Mutation: 

   
   
How to run:
C1: node server.js (default)
C2: npm run start (according to scripts)
https://www.youtube.com/watch?v=AEptYkblFg8&list=PLKzNGvIJtUDZt5GlzARgHUVFaTzfQytJV&index=2
